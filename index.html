<!DOCTYPE html>
<html>
	<head>
		<title>OSM LOD INDEX</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8;" />
		<style type="text/css">
			html, body, #basicMap {
				width: 100%;
				height: 100%;
				margin: 0;
				z-index: 0;
			}
		</style>
		<script src="http://www.openlayers.org/api/OpenLayers.js"></script>
		<script src="js/lib/jquery.js" type="text/javascript"></script>
		<script src="js/requests.js" type="text/javascript"></script>
		<script src="js/map.js" type="text/javascript"></script>
		<script src="js/stations.js"></script>
		<script src="js/JarvisMarch.js" type="text/javascript"></script>
		<!-- <script src="js/dataViewer.js" type="text/javascript"></script> -->
		<script>		
			// global variables
			var map, strategy, clusters, markers, icon;
			// array containing the vector features(stations)
			var features = [];
			// array containing only the coordinates of the vector features(as OpenLayers.Geometry.Point)
			var stationsArr = [];
			
			var hull = new JarvisMarch();
			
			// initiate the map and the station vector layer with all stations as vector features
			function init(){
				map = new OpenLayers.Map("basicMap");
				var mapnik = new OpenLayers.Layer.OSM();
				map.addLayer(mapnik);
				map.setCenter(new OpenLayers.LonLat(13.41, 52.52)// Center of the map
				.transform(new OpenLayers.Projection("EPSG:4326"), // transform from WGS 1984
				new OpenLayers.Projection("EPSG:900913") // to Spherical Mercator Projection
				), 3 // Zoom level
				);
				
	            
	           	// style of the vector features(stations)
				var style = new OpenLayers.Style({
                    pointRadius: "${radius}",
                    fillColor: "${color}",
                    fillOpacity: 0.8,
                    strokeColor: "#cc6633",
                    strokeWidth: "${width}",
                    strokeOpacity: 0.8,
                    label: "${label}"
                }, {
                    context: {
                        width: function(feature) {
                            return (feature.cluster) ? 2 : 1;
                        },
                        radius: function(feature) {
                            var pix = 2;
                            if(feature.cluster) {
                                pix = Math.min(feature.attributes.count, 7) + 4;
                            }
                            else pix = 5;
                            return pix;
                        },
                        label: function(feature) {
                        	if(feature.cluster){
                        		if(feature.attributes.count > 1)	return feature.attributes.count;
                        		else return "";
                        	}
                        	else return "";
                        },
                        color: function(feature) {
                        	if(feature.cluster){
                        		if(feature.attributes.count > 1) return "#ffcc66";
                        		else return "#2E9AFE";
                        	}
                        	else return "#2E9AFE";
                        }
                    }
                });
                
                // Cluster Strategy
                strategy = new OpenLayers.Strategy.Cluster();
                strategy.distance = 50;
                strategy.threshold = 4;
                polyLayer = new OpenLayers.Layer.Vector("Polygons");
                map.addLayer(polyLayer);

				// vector layer with the stations
                clusters = new OpenLayers.Layer.Vector("Clusters", {
                    strategies: [strategy],
                    title: "Station Layer",
                    eventListeners: {
                    	featureout: function(e) {
                    		if(e.feature.attributes.count > 1){
                    			if(polyLayer.features.length > 0) polyLayer.removeAllFeatures();	
                    		}
                    	},
                    	featureover: function(e) {
                    		if(e.feature.attributes.count > 1){
                    			var pointsP = [];
                    			e.feature.cluster.forEach(function(feature){
                    				pointsP.push(feature.geometry);
                    			});
                    			// console.log(hull.computeHull(pointsP));
                    			//console.log("Result: " + hull.getHullPoints()[0]);
                    			if(pointsP.length > 3)	var ring = new OpenLayers.Geometry.LinearRing(hull.computeHull(pointsP));
                    			else 					var ring = new OpenLayers.Geometry.LinearRing(pointsP);
                    			var polygon = new OpenLayers.Geometry.Polygon([ring]);
                    			var polyFeature = new OpenLayers.Feature.Vector(ring);
                    			polyLayer.addFeatures([polyFeature]);
                    		}
                    	},
				        featureclick: function(e) {
				        	if(e.feature.attributes.count > 1){
				        		if(polyLayer.features.length > 0) polyLayer.removeAllFeatures();	
				        		var cluster_bounds = new OpenLayers.Bounds();
								e.feature.cluster.forEach(function(feature){
								    cluster_bounds.extend(feature.geometry);
								});
								map.zoomToExtent(cluster_bounds);
				        	}
				            else clickEvent(e.feature.geometry);
				        }
				    },
                    styleMap: new OpenLayers.StyleMap({
                        "default": style,
                        "select": {
                            fillColor: "#8aeeef",
                            strokeColor: "#32a8a9"
                        }
                    })
                });
                
                // properties of the marker inidicating the selected station
                var size = new OpenLayers.Size(21, 25);
				var offset = new OpenLayers.Pixel(-(size.w / 2), -size.h);
				icon = new OpenLayers.Icon('http://www.openlayers.org/dev/img/marker.png', size, offset);
				markers = new OpenLayers.Layer.Markers("Stations");
				map.addLayer(markers);
                
                // selects the station closest the click event
                map.events.register('click', map, function(evt) {
                	while( map.popups.length ) {
				         map.removePopup(map.popups[0]);
				    }
					// var lonlat = map.getLonLatFromViewPortPx(evt.xy);
					// console.log("LonLat: " + lonlat.lon + "|" + lonlat.lat);
					// var point = new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat);
					// clickEvent(point);
				});
				
				
                // defines hover event for the clusters
                var select = new OpenLayers.Control.SelectFeature(
                    clusters, {hover: true}
                );
                map.addControl(select);
                select.activate();
                
                
                map.addLayer(clusters);
                
                
                // loadStations();
                getStationsJSON();
			}

		</script>
	</head>
	<body onload="init();">
		<div id="loadingAnimation" style="width: 400px; height: 200px; position: absolute; background-color: white; border: 1px solid black;">
			<h1 style="text-align: center; margin: 5px;">Loading</h1>
			<table>
				<tr>
					<td><img src="pics/globeSpinner.GIF" style="padding: 5px;"></td>
					<td valign="center"><h3>Data is being requested. This may take up to 60 seconds. Please wait.</h3></td>
				</tr>
			</table>
			
		</div>
		
		<iframe id="dataViewer" style="overflow: hidden;" src="data.php">
			
		</iframe>
		<script type="text/javascript">
			$("#loadingAnimation").hide();
			$("#dataViewer").hide();
			var frame = document.getElementById('dataViewer').contentWindow;
		</script>
		<div id="basicMap">
						
		</div>
	</body>

</html>